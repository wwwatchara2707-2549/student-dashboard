{"version":3,"file":"async-slider.js","mappings":"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","sources":["webpack:///../src/number.ts","webpack:///../src/direction.tsx","webpack:///../src/ordered-dictionary.ts","webpack:///../src/slider.tsx","webpack:///../src/collection-legacy.tsx","webpack:///../src/use-previous.tsx","webpack:///./node_modules/ramda/es/pickBy.js","webpack:///./node_modules/d3-format/src/formatDecimal.js","webpack:///./node_modules/d3-format/src/formatSpecifier.js","webpack:///./node_modules/d3-format/src/formatPrefixAuto.js","webpack:///./node_modules/d3-format/src/formatRounded.js","webpack:///./node_modules/d3-format/src/formatTypes.js","webpack:///./node_modules/d3-format/src/identity.js","webpack:///./node_modules/d3-format/src/locale.js","webpack:///./node_modules/d3-format/src/defaultLocale.js","webpack:///./node_modules/d3-format/src/formatGroup.js","webpack:///./node_modules/d3-format/src/formatNumerals.js","webpack:///./node_modules/d3-format/src/formatTrim.js","webpack:///./node_modules/d3-format/src/exponent.js","webpack:///./src/utils/computeSliderMarkers.ts","webpack:///./src/utils/sliderSnapToMark.ts","webpack:///./src/utils/sliderRendering.tsx","webpack:///./node_modules/ramda/es/replace.js","webpack:///./node_modules/ramda/es/internal/_arity.js","webpack:///./node_modules/ramda/es/internal/_pipe.js","webpack:///./node_modules/ramda/es/internal/_isArrayLike.js","webpack:///./node_modules/ramda/es/internal/_createReduce.js","webpack:///./node_modules/ramda/es/internal/_xArrayReduce.js","webpack:///./node_modules/ramda/es/bind.js","webpack:///./node_modules/ramda/es/internal/_xReduce.js","webpack:///./node_modules/ramda/es/internal/_xwrap.js","webpack:///./node_modules/ramda/es/reduce.js","webpack:///./node_modules/ramda/es/internal/_checkForMethod.js","webpack:///./node_modules/ramda/es/slice.js","webpack:///./node_modules/ramda/es/tail.js","webpack:///./node_modules/ramda/es/internal/_curryN.js","webpack:///./node_modules/ramda/es/curryN.js","webpack:///./node_modules/ramda/es/invoker.js","webpack:///./node_modules/ramda/es/split.js","webpack:///./node_modules/ramda/es/internal/_isInteger.js","webpack:///./node_modules/ramda/es/internal/_nth.js","webpack:///./node_modules/ramda/es/internal/_path.js","webpack:///./node_modules/ramda/es/path.js","webpack:///./src/utils/sliderTooltip.tsx","webpack:///./src/utils/formatSliderTooltip.ts","webpack:///./node_modules/ramda/es/pipe.js","webpack:///./src/fragments/RangeSlider.tsx"],"sourcesContent":["function clamp(value: number, [min, max]: [number, number]): number {\n  return Math.min(max, Math.max(min, value));\n}\n\nexport { clamp };\n","import * as React from 'react';\n\ntype Direction = 'ltr' | 'rtl';\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\n/* -------------------------------------------------------------------------------------------------\n * Direction\n * -----------------------------------------------------------------------------------------------*/\n\ninterface DirectionProviderProps {\n  children?: React.ReactNode;\n  dir: Direction;\n}\nconst DirectionProvider: React.FC<DirectionProviderProps> = (props) => {\n  const { dir, children } = props;\n  return <DirectionContext.Provider value={dir}>{children}</DirectionContext.Provider>;\n};\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction useDirection(localDir?: Direction) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || 'ltr';\n}\n\nconst Provider = DirectionProvider;\n\nexport {\n  useDirection,\n  //\n  Provider,\n  //\n  DirectionProvider,\n};\n","// Not a real member because it shouldn't be accessible, but the super class\n// calls `set` which needs to read the instanciation state, so it can't be a\n// private member.\nconst __instanciated = new WeakMap<OrderedDict<any, any>, boolean>();\nexport class OrderedDict<K, V> extends Map<K, V> {\n  #keys: K[];\n\n  constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    super(entries);\n    this.#keys = [...super.keys()];\n    __instanciated.set(this, true);\n  }\n\n  set(key: K, value: V) {\n    if (__instanciated.get(this)) {\n      if (this.has(key)) {\n        this.#keys[this.#keys.indexOf(key)] = key;\n      } else {\n        this.#keys.push(key);\n      }\n    }\n    super.set(key, value);\n    return this;\n  }\n\n  insert(index: number, key: K, value: V) {\n    const has = this.has(key);\n    const length = this.#keys.length;\n    const relativeIndex = toSafeInteger(index);\n    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n\n    if (safeIndex === this.size || (has && safeIndex === this.size - 1) || safeIndex === -1) {\n      this.set(key, value);\n      return this;\n    }\n\n    const size = this.size + (has ? 0 : 1);\n\n    // If you insert at, say, -2, without this bit you'd replace the\n    // second-to-last item and push the rest up one, which means the new item is\n    // 3rd to last. This isn't very intuitive; inserting at -2 is more like\n    // saying \"make this item the second to last\".\n    if (relativeIndex < 0) {\n      actualIndex++;\n    }\n\n    const keys = [...this.#keys];\n    let nextValue: V | undefined;\n    let shouldSkip = false;\n    for (let i = actualIndex; i < size; i++) {\n      if (actualIndex === i) {\n        let nextKey = keys[i]!;\n        if (keys[i] === key) {\n          nextKey = keys[i + 1]!;\n        }\n        if (has) {\n          // delete first to ensure that the item is moved to the end\n          this.delete(key);\n        }\n        nextValue = this.get(nextKey);\n        this.set(key, value);\n      } else {\n        if (!shouldSkip && keys[i - 1] === key) {\n          shouldSkip = true;\n        }\n        const currentKey = keys[shouldSkip ? i : i - 1]!;\n        const currentValue = nextValue!;\n        nextValue = this.get(currentKey);\n        this.delete(currentKey);\n        this.set(currentKey, currentValue);\n      }\n    }\n    return this;\n  }\n\n  with(index: number, key: K, value: V) {\n    const copy = new OrderedDict(this);\n    copy.insert(index, key, value);\n    return copy;\n  }\n\n  before(key: K) {\n    const index = this.#keys.indexOf(key) - 1;\n    if (index < 0) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position before the given key.\n   */\n  setBefore(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index, newKey, value);\n  }\n\n  after(key: K) {\n    let index = this.#keys.indexOf(key);\n    index = index === -1 || index === this.size - 1 ? -1 : index + 1;\n    if (index === -1) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position after the given key.\n   */\n  setAfter(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index + 1, newKey, value);\n  }\n\n  first() {\n    return this.entryAt(0);\n  }\n\n  last() {\n    return this.entryAt(-1);\n  }\n\n  clear() {\n    this.#keys = [];\n    return super.clear();\n  }\n\n  delete(key: K) {\n    const deleted = super.delete(key);\n    if (deleted) {\n      this.#keys.splice(this.#keys.indexOf(key), 1);\n    }\n    return deleted;\n  }\n\n  deleteAt(index: number) {\n    const key = this.keyAt(index);\n    if (key !== undefined) {\n      return this.delete(key);\n    }\n    return false;\n  }\n\n  at(index: number) {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return this.get(key);\n    }\n  }\n\n  entryAt(index: number): [K, V] | undefined {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return [key, this.get(key)!];\n    }\n  }\n\n  indexOf(key: K) {\n    return this.#keys.indexOf(key);\n  }\n\n  keyAt(index: number) {\n    return at(this.#keys, index);\n  }\n\n  from(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.at(dest);\n  }\n\n  keyFrom(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.keyAt(dest);\n  }\n\n  find(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return entry;\n      }\n      index++;\n    }\n    return undefined;\n  }\n\n  findIndex(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return index;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  filter<KK extends K, VV extends V>(\n    predicate: (entry: [K, V], index: number, dict: OrderedDict<K, V>) => entry is [KK, VV],\n    thisArg?: any\n  ): OrderedDict<KK, VV>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ): OrderedDict<K, V>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    const entries: Array<[K, V]> = [];\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        entries.push(entry);\n      }\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  map<U>(\n    callbackfn: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => U,\n    thisArg?: any\n  ): OrderedDict<K, U> {\n    const entries: [K, U][] = [];\n    let index = 0;\n    for (const entry of this) {\n      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduce<U>(\n    callbackfn: (\n      previousValue: U,\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduce<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let index = 0;\n    let accumulator = initialValue ?? this.at(0)!;\n    for (const entry of this) {\n      if (index === 0 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n      index++;\n    }\n    return accumulator;\n  }\n\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduceRight<U>(\n    callbackfn: (\n      previousValue: [K, V],\n      currentValue: U,\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduceRight<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let accumulator = initialValue ?? this.at(-1)!;\n    for (let index = this.size - 1; index >= 0; index--) {\n      const entry = this.at(index)!;\n      if (index === this.size - 1 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n    }\n    return accumulator;\n  }\n\n  toSorted(compareFn?: (a: [K, V], b: [K, V]) => number): OrderedDict<K, V> {\n    const entries = [...this.entries()].sort(compareFn);\n    return new OrderedDict(entries);\n  }\n\n  toReversed(): OrderedDict<K, V> {\n    const reversed = new OrderedDict<K, V>();\n    for (let index = this.size - 1; index >= 0; index--) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      reversed.set(key, element);\n    }\n    return reversed;\n  }\n\n  toSpliced(start: number, deleteCount?: number): OrderedDict<K, V>;\n  toSpliced(start: number, deleteCount: number, ...items: [K, V][]): OrderedDict<K, V>;\n\n  toSpliced(...args: [start: number, deleteCount: number, ...items: [K, V][]]) {\n    const entries = [...this.entries()];\n    entries.splice(...args);\n    return new OrderedDict(entries);\n  }\n\n  slice(start?: number, end?: number) {\n    const result = new OrderedDict<K, V>();\n    let stop = this.size - 1;\n\n    if (start === undefined) {\n      return result;\n    }\n\n    if (start < 0) {\n      start = start + this.size;\n    }\n\n    if (end !== undefined && end > 0) {\n      stop = end - 1;\n    }\n\n    for (let index = start; index <= stop; index++) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      result.set(key, element);\n    }\n    return result;\n  }\n\n  every(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n\n  some(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return true;\n      }\n      index++;\n    }\n    return false;\n  }\n}\n\nexport type KeyOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<infer K, any> ? K : never;\nexport type ValueOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<any, infer V> ? V : never;\nexport type EntryOf<D extends OrderedDict<any, any>> = [KeyOf<D>, ValueOf<D>];\nexport type KeyFrom<E extends EntryOf<any>> = E[0];\nexport type ValueFrom<E extends EntryOf<any>> = E[1];\n\nfunction at<T>(array: ArrayLike<T>, index: number): T | undefined {\n  if ('at' in Array.prototype) {\n    return Array.prototype.at.call(array, index);\n  }\n  const actualIndex = toSafeIndex(array, index);\n  return actualIndex === -1 ? undefined : array[actualIndex];\n}\n\nfunction toSafeIndex(array: ArrayLike<any>, index: number) {\n  const length = array.length;\n  const relativeIndex = toSafeInteger(index);\n  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n}\n\nfunction toSafeInteger(number: number) {\n  // eslint-disable-next-line no-self-compare\n  return number !== number || number === 0 ? 0 : Math.trunc(number);\n}\n","import * as React from 'react';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { createCollection } from '@radix-ui/react-collection';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst PAGE_KEYS = ['PageUp', 'PageDown'];\nconst ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\ntype SlideDirection = 'from-left' | 'from-right' | 'from-bottom' | 'from-top';\nconst BACK_KEYS: Record<SlideDirection, string[]> = {\n  'from-left': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-right': ['Home', 'PageDown', 'ArrowDown', 'ArrowRight'],\n  'from-bottom': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-top': ['Home', 'PageDown', 'ArrowUp', 'ArrowLeft'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Slider\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLIDER_NAME = 'Slider';\n\nconst [Collection, useCollection, createCollectionScope] =\n  createCollection<SliderThumbElement>(SLIDER_NAME);\n\ntype ScopedProps<P> = P & { __scopeSlider?: Scope };\nconst [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [\n  createCollectionScope,\n]);\n\ntype SliderContextValue = {\n  name: string | undefined;\n  disabled: boolean | undefined;\n  min: number;\n  max: number;\n  values: number[];\n  valueIndexToChangeRef: React.MutableRefObject<number>;\n  thumbs: Set<SliderThumbElement>;\n  orientation: SliderProps['orientation'];\n  form: string | undefined;\n};\n\nconst [SliderProvider, useSliderContext] = createSliderContext<SliderContextValue>(SLIDER_NAME);\n\ntype SliderElement = SliderHorizontalElement | SliderVerticalElement;\ninterface SliderProps\n  extends Omit<\n    SliderHorizontalProps | SliderVerticalProps,\n    keyof SliderOrientationPrivateProps | 'defaultValue'\n  > {\n  name?: string;\n  disabled?: boolean;\n  orientation?: React.AriaAttributes['aria-orientation'];\n  dir?: Direction;\n  min?: number;\n  max?: number;\n  step?: number;\n  minStepsBetweenThumbs?: number;\n  value?: number[];\n  defaultValue?: number[];\n  onValueChange?(value: number[]): void;\n  onValueCommit?(value: number[]): void;\n  inverted?: boolean;\n  form?: string;\n}\n\nconst Slider = React.forwardRef<SliderElement, SliderProps>(\n  (props: ScopedProps<SliderProps>, forwardedRef) => {\n    const {\n      name,\n      min = 0,\n      max = 100,\n      step = 1,\n      orientation = 'horizontal',\n      disabled = false,\n      minStepsBetweenThumbs = 0,\n      defaultValue = [min],\n      value,\n      onValueChange = () => {},\n      onValueCommit = () => {},\n      inverted = false,\n      form,\n      ...sliderProps\n    } = props;\n    const thumbRefs = React.useRef<SliderContextValue['thumbs']>(new Set());\n    const valueIndexToChangeRef = React.useRef<number>(0);\n    const isHorizontal = orientation === 'horizontal';\n    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;\n\n    const [values = [], setValues] = useControllableState({\n      prop: value,\n      defaultProp: defaultValue,\n      onChange: (value) => {\n        const thumbs = [...thumbRefs.current];\n        thumbs[valueIndexToChangeRef.current]?.focus();\n        onValueChange(value);\n      },\n    });\n    const valuesBeforeSlideStartRef = React.useRef(values);\n\n    function handleSlideStart(value: number) {\n      const closestIndex = getClosestValueIndex(values, value);\n      updateValues(value, closestIndex);\n    }\n\n    function handleSlideMove(value: number) {\n      updateValues(value, valueIndexToChangeRef.current);\n    }\n\n    function handleSlideEnd() {\n      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];\n      const nextValue = values[valueIndexToChangeRef.current];\n      const hasChanged = nextValue !== prevValue;\n      if (hasChanged) onValueCommit(values);\n    }\n\n    function updateValues(value: number, atIndex: number, { commit } = { commit: false }) {\n      const decimalCount = getDecimalCount(step);\n      const snapToStep = roundValue(Math.round((value - min) / step) * step + min, decimalCount);\n      const nextValue = clamp(snapToStep, [min, max]);\n\n      setValues((prevValues = []) => {\n        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);\n        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {\n          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);\n          const hasChanged = String(nextValues) !== String(prevValues);\n          if (hasChanged && commit) onValueCommit(nextValues);\n          return hasChanged ? nextValues : prevValues;\n        } else {\n          return prevValues;\n        }\n      });\n    }\n\n    return (\n      <SliderProvider\n        scope={props.__scopeSlider}\n        name={name}\n        disabled={disabled}\n        min={min}\n        max={max}\n        valueIndexToChangeRef={valueIndexToChangeRef}\n        thumbs={thumbRefs.current}\n        values={values}\n        orientation={orientation}\n        form={form}\n      >\n        <Collection.Provider scope={props.__scopeSlider}>\n          <Collection.Slot scope={props.__scopeSlider}>\n            <SliderOrientation\n              aria-disabled={disabled}\n              data-disabled={disabled ? '' : undefined}\n              {...sliderProps}\n              ref={forwardedRef}\n              onPointerDown={composeEventHandlers(sliderProps.onPointerDown, () => {\n                if (!disabled) valuesBeforeSlideStartRef.current = values;\n              })}\n              min={min}\n              max={max}\n              inverted={inverted}\n              onSlideStart={disabled ? undefined : handleSlideStart}\n              onSlideMove={disabled ? undefined : handleSlideMove}\n              onSlideEnd={disabled ? undefined : handleSlideEnd}\n              onHomeKeyDown={() => !disabled && updateValues(min, 0, { commit: true })}\n              onEndKeyDown={() =>\n                !disabled && updateValues(max, values.length - 1, { commit: true })\n              }\n              onStepKeyDown={({ event, direction: stepDirection }) => {\n                if (!disabled) {\n                  const isPageKey = PAGE_KEYS.includes(event.key);\n                  const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));\n                  const multiplier = isSkipKey ? 10 : 1;\n                  const atIndex = valueIndexToChangeRef.current;\n                  const value = values[atIndex]!;\n                  const stepInDirection = step * multiplier * stepDirection;\n                  updateValues(value + stepInDirection, atIndex, { commit: true });\n                }\n              }}\n            />\n          </Collection.Slot>\n        </Collection.Provider>\n      </SliderProvider>\n    );\n  }\n);\n\nSlider.displayName = SLIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderHorizontal\n * -----------------------------------------------------------------------------------------------*/\n\ntype Side = 'top' | 'right' | 'bottom' | 'left';\n\nconst [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext<{\n  startEdge: Side;\n  endEdge: Side;\n  size: keyof NonNullable<ReturnType<typeof useSize>>;\n  direction: number;\n}>(SLIDER_NAME, {\n  startEdge: 'left',\n  endEdge: 'right',\n  size: 'width',\n  direction: 1,\n});\n\ntype SliderOrientationPrivateProps = {\n  min: number;\n  max: number;\n  inverted: boolean;\n  onSlideStart?(value: number): void;\n  onSlideMove?(value: number): void;\n  onSlideEnd?(): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(step: { event: React.KeyboardEvent; direction: number }): void;\n};\ninterface SliderOrientationProps\n  extends Omit<SliderImplProps, keyof SliderImplPrivateProps>,\n    SliderOrientationPrivateProps {}\n\ntype SliderHorizontalElement = SliderImplElement;\ninterface SliderHorizontalProps extends SliderOrientationProps {\n  dir?: Direction;\n}\n\nconst SliderHorizontal = React.forwardRef<SliderHorizontalElement, SliderHorizontalProps>(\n  (props: ScopedProps<SliderHorizontalProps>, forwardedRef) => {\n    const {\n      min,\n      max,\n      dir,\n      inverted,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const [slider, setSlider] = React.useState<SliderImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));\n    const rectRef = React.useRef<DOMRect>(undefined);\n    const direction = useDirection(dir);\n    const isDirectionLTR = direction === 'ltr';\n    const isSlidingFromLeft = (isDirectionLTR && !inverted) || (!isDirectionLTR && inverted);\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || slider!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.width];\n      const output: [number, number] = isSlidingFromLeft ? [min, max] : [max, min];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.left);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge={isSlidingFromLeft ? 'left' : 'right'}\n        endEdge={isSlidingFromLeft ? 'right' : 'left'}\n        direction={isSlidingFromLeft ? 1 : -1}\n        size=\"width\"\n      >\n        <SliderImpl\n          dir={direction}\n          data-orientation=\"horizontal\"\n          {...sliderProps}\n          ref={composedRefs}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateX(-50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => {\n            rectRef.current = undefined;\n            onSlideEnd?.();\n          }}\n          onStepKeyDown={(event) => {\n            const slideDirection = isSlidingFromLeft ? 'from-left' : 'from-right';\n            const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderVertical\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderVerticalElement = SliderImplElement;\ninterface SliderVerticalProps extends SliderOrientationProps {}\n\nconst SliderVertical = React.forwardRef<SliderVerticalElement, SliderVerticalProps>(\n  (props: ScopedProps<SliderVerticalProps>, forwardedRef) => {\n    const {\n      min,\n      max,\n      inverted,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const sliderRef = React.useRef<SliderImplElement>(null);\n    const ref = useComposedRefs(forwardedRef, sliderRef);\n    const rectRef = React.useRef<DOMRect>(undefined);\n    const isSlidingFromBottom = !inverted;\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || sliderRef.current!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.height];\n      const output: [number, number] = isSlidingFromBottom ? [max, min] : [min, max];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.top);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge={isSlidingFromBottom ? 'bottom' : 'top'}\n        endEdge={isSlidingFromBottom ? 'top' : 'bottom'}\n        size=\"height\"\n        direction={isSlidingFromBottom ? 1 : -1}\n      >\n        <SliderImpl\n          data-orientation=\"vertical\"\n          {...sliderProps}\n          ref={ref}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateY(50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => {\n            rectRef.current = undefined;\n            onSlideEnd?.();\n          }}\n          onStepKeyDown={(event) => {\n            const slideDirection = isSlidingFromBottom ? 'from-bottom' : 'from-top';\n            const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderImpl\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderImplElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ntype SliderImplPrivateProps = {\n  onSlideStart(event: React.PointerEvent): void;\n  onSlideMove(event: React.PointerEvent): void;\n  onSlideEnd(event: React.PointerEvent): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(event: React.KeyboardEvent): void;\n};\ninterface SliderImplProps extends PrimitiveDivProps, SliderImplPrivateProps {}\n\nconst SliderImpl = React.forwardRef<SliderImplElement, SliderImplProps>(\n  (props: ScopedProps<SliderImplProps>, forwardedRef) => {\n    const {\n      __scopeSlider,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onHomeKeyDown,\n      onEndKeyDown,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const context = useSliderContext(SLIDER_NAME, __scopeSlider);\n\n    return (\n      <Primitive.span\n        {...sliderProps}\n        ref={forwardedRef}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          if (event.key === 'Home') {\n            onHomeKeyDown(event);\n            // Prevent scrolling to page start\n            event.preventDefault();\n          } else if (event.key === 'End') {\n            onEndKeyDown(event);\n            // Prevent scrolling to page end\n            event.preventDefault();\n          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\n            onStepKeyDown(event);\n            // Prevent scrolling for directional key presses\n            event.preventDefault();\n          }\n        })}\n        onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n          const target = event.target as HTMLElement;\n          target.setPointerCapture(event.pointerId);\n          // Prevent browser focus behaviour because we focus a thumb manually when values change.\n          event.preventDefault();\n          // Touch devices have a delay before focusing so won't focus if touch immediately moves\n          // away from target (sliding). We want thumb to focus regardless.\n          if (context.thumbs.has(target)) {\n            target.focus();\n          } else {\n            onSlideStart(event);\n          }\n        })}\n        onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);\n        })}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) {\n            target.releasePointerCapture(event.pointerId);\n            onSlideEnd(event);\n          }\n        })}\n      />\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderTrack\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRACK_NAME = 'SliderTrack';\n\ntype SliderTrackElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SliderTrackProps extends PrimitiveSpanProps {}\n\nconst SliderTrack = React.forwardRef<SliderTrackElement, SliderTrackProps>(\n  (props: ScopedProps<SliderTrackProps>, forwardedRef) => {\n    const { __scopeSlider, ...trackProps } = props;\n    const context = useSliderContext(TRACK_NAME, __scopeSlider);\n    return (\n      <Primitive.span\n        data-disabled={context.disabled ? '' : undefined}\n        data-orientation={context.orientation}\n        {...trackProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nSliderTrack.displayName = TRACK_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderRange\n * -----------------------------------------------------------------------------------------------*/\n\nconst RANGE_NAME = 'SliderRange';\n\ntype SliderRangeElement = React.ComponentRef<typeof Primitive.span>;\ninterface SliderRangeProps extends PrimitiveSpanProps {}\n\nconst SliderRange = React.forwardRef<SliderRangeElement, SliderRangeProps>(\n  (props: ScopedProps<SliderRangeProps>, forwardedRef) => {\n    const { __scopeSlider, ...rangeProps } = props;\n    const context = useSliderContext(RANGE_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);\n    const ref = React.useRef<HTMLSpanElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const valuesCount = context.values.length;\n    const percentages = context.values.map((value) =>\n      convertValueToPercentage(value, context.min, context.max)\n    );\n    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;\n    const offsetEnd = 100 - Math.max(...percentages);\n\n    return (\n      <Primitive.span\n        data-orientation={context.orientation}\n        data-disabled={context.disabled ? '' : undefined}\n        {...rangeProps}\n        ref={composedRefs}\n        style={{\n          ...props.style,\n          [orientation.startEdge]: offsetStart + '%',\n          [orientation.endEdge]: offsetEnd + '%',\n        }}\n      />\n    );\n  }\n);\n\nSliderRange.displayName = RANGE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'SliderThumb';\n\ntype SliderThumbElement = SliderThumbImplElement;\ninterface SliderThumbProps extends Omit<SliderThumbImplProps, 'index'> {}\n\nconst SliderThumb = React.forwardRef<SliderThumbElement, SliderThumbProps>(\n  (props: ScopedProps<SliderThumbProps>, forwardedRef) => {\n    const getItems = useCollection(props.__scopeSlider);\n    const [thumb, setThumb] = React.useState<SliderThumbImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const index = React.useMemo(\n      () => (thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1),\n      [getItems, thumb]\n    );\n    return <SliderThumbImpl {...props} ref={composedRefs} index={index} />;\n  }\n);\n\ntype SliderThumbImplElement = React.ComponentRef<typeof Primitive.span>;\ninterface SliderThumbImplProps extends PrimitiveSpanProps {\n  index: number;\n  name?: string;\n}\n\nconst SliderThumbImpl = React.forwardRef<SliderThumbImplElement, SliderThumbImplProps>(\n  (props: ScopedProps<SliderThumbImplProps>, forwardedRef) => {\n    const { __scopeSlider, index, name, ...thumbProps } = props;\n    const context = useSliderContext(THUMB_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);\n    const [thumb, setThumb] = React.useState<HTMLSpanElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = thumb ? context.form || !!thumb.closest('form') : true;\n    const size = useSize(thumb);\n    // We cast because index could be `-1` which would return undefined\n    const value = context.values[index] as number | undefined;\n    const percent =\n      value === undefined ? 0 : convertValueToPercentage(value, context.min, context.max);\n    const label = getLabel(index, context.values.length);\n    const orientationSize = size?.[orientation.size];\n    const thumbInBoundsOffset = orientationSize\n      ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction)\n      : 0;\n\n    React.useEffect(() => {\n      if (thumb) {\n        context.thumbs.add(thumb);\n        return () => {\n          context.thumbs.delete(thumb);\n        };\n      }\n    }, [thumb, context.thumbs]);\n\n    return (\n      <span\n        style={{\n          transform: 'var(--radix-slider-thumb-transform)',\n          position: 'absolute',\n          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`,\n        }}\n      >\n        <Collection.ItemSlot scope={props.__scopeSlider}>\n          <Primitive.span\n            role=\"slider\"\n            aria-label={props['aria-label'] || label}\n            aria-valuemin={context.min}\n            aria-valuenow={value}\n            aria-valuemax={context.max}\n            aria-orientation={context.orientation}\n            data-orientation={context.orientation}\n            data-disabled={context.disabled ? '' : undefined}\n            tabIndex={context.disabled ? undefined : 0}\n            {...thumbProps}\n            ref={composedRefs}\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            style={value === undefined ? { display: 'none' } : props.style}\n            onFocus={composeEventHandlers(props.onFocus, () => {\n              context.valueIndexToChangeRef.current = index;\n            })}\n          />\n        </Collection.ItemSlot>\n\n        {isFormControl && (\n          <SliderBubbleInput\n            key={index}\n            name={\n              name ??\n              (context.name ? context.name + (context.values.length > 1 ? '[]' : '') : undefined)\n            }\n            form={context.form}\n            value={value}\n          />\n        )}\n      </span>\n    );\n  }\n);\n\nSliderThumb.displayName = THUMB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderBubbleInput\n * -----------------------------------------------------------------------------------------------*/\n\nconst BUBBLE_INPUT_NAME = 'RadioBubbleInput';\n\ntype InputProps = React.ComponentPropsWithoutRef<typeof Primitive.input>;\ninterface SliderBubbleInputProps extends InputProps {}\n\nconst SliderBubbleInput = React.forwardRef<HTMLInputElement, SliderBubbleInputProps>(\n  ({ __scopeSlider, value, ...props }: ScopedProps<SliderBubbleInputProps>, forwardedRef) => {\n    const ref = React.useRef<HTMLInputElement>(null);\n    const composedRefs = useComposedRefs(ref, forwardedRef);\n    const prevValue = usePrevious(value);\n\n    // Bubble value change to parents (e.g form change event)\n    React.useEffect(() => {\n      const input = ref.current;\n      if (!input) return;\n\n      const inputProto = window.HTMLInputElement.prototype;\n      const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'value') as PropertyDescriptor;\n      const setValue = descriptor.set;\n      if (prevValue !== value && setValue) {\n        const event = new Event('input', { bubbles: true });\n        setValue.call(input, value);\n        input.dispatchEvent(event);\n      }\n    }, [prevValue, value]);\n\n    /**\n     * We purposefully do not use `type=\"hidden\"` here otherwise forms that\n     * wrap it will not be able to access its value via the FormData API.\n     *\n     * We purposefully do not add the `value` attribute here to allow the value\n     * to be set programmatically and bubble to any parent form `onChange` event.\n     * Adding the `value` will cause React to consider the programmatic\n     * dispatch a duplicate and it will get swallowed.\n     */\n    return (\n      <Primitive.input\n        style={{ display: 'none' }}\n        {...props}\n        ref={composedRefs}\n        defaultValue={value}\n      />\n    );\n  }\n);\n\nSliderBubbleInput.displayName = BUBBLE_INPUT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getNextSortedValues(prevValues: number[] = [], nextValue: number, atIndex: number) {\n  const nextValues = [...prevValues];\n  nextValues[atIndex] = nextValue;\n  return nextValues.sort((a, b) => a - b);\n}\n\nfunction convertValueToPercentage(value: number, min: number, max: number) {\n  const maxSteps = max - min;\n  const percentPerStep = 100 / maxSteps;\n  const percentage = percentPerStep * (value - min);\n  return clamp(percentage, [0, 100]);\n}\n\n/**\n * Returns a label for each thumb when there are two or more thumbs\n */\nfunction getLabel(index: number, totalValues: number) {\n  if (totalValues > 2) {\n    return `Value ${index + 1} of ${totalValues}`;\n  } else if (totalValues === 2) {\n    return ['Minimum', 'Maximum'][index];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Given a `values` array and a `nextValue`, determine which value in\n * the array is closest to `nextValue` and return its index.\n *\n * @example\n * // returns 1\n * getClosestValueIndex([10, 30], 25);\n */\nfunction getClosestValueIndex(values: number[], nextValue: number) {\n  if (values.length === 1) return 0;\n  const distances = values.map((value) => Math.abs(value - nextValue));\n  const closestDistance = Math.min(...distances);\n  return distances.indexOf(closestDistance);\n}\n\n/**\n * Offsets the thumb centre point while sliding to ensure it remains\n * within the bounds of the slider when reaching the edges\n */\nfunction getThumbInBoundsOffset(width: number, left: number, direction: number) {\n  const halfWidth = width / 2;\n  const halfPercent = 50;\n  const offset = linearScale([0, halfPercent], [0, halfWidth]);\n  return (halfWidth - offset(left) * direction) * direction;\n}\n\n/**\n * Gets an array of steps between each value.\n *\n * @example\n * // returns [1, 9]\n * getStepsBetweenValues([10, 11, 20]);\n */\nfunction getStepsBetweenValues(values: number[]) {\n  return values.slice(0, -1).map((value, index) => values[index + 1]! - value);\n}\n\n/**\n * Verifies the minimum steps between all values is greater than or equal\n * to the expected minimum steps.\n *\n * @example\n * // returns false\n * hasMinStepsBetweenValues([1,2,3], 2);\n *\n * @example\n * // returns true\n * hasMinStepsBetweenValues([1,2,3], 1);\n */\nfunction hasMinStepsBetweenValues(values: number[], minStepsBetweenValues: number) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values);\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\n  }\n  return true;\n}\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nfunction linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nfunction getDecimalCount(value: number) {\n  return (String(value).split('.')[1] || '').length;\n}\n\nfunction roundValue(value: number, decimalCount: number) {\n  const rounder = Math.pow(10, decimalCount);\n  return Math.round(value * rounder) / rounder;\n}\n\nconst Root = Slider;\nconst Track = SliderTrack;\nconst Range = SliderRange;\nconst Thumb = SliderThumb;\n\nexport {\n  createSliderScope,\n  //\n  Slider,\n  SliderTrack,\n  SliderRange,\n  SliderThumb,\n  //\n  Root,\n  Track,\n  Range,\n  Thumb,\n};\nexport type { SliderProps, SliderTrackProps, SliderRangeProps, SliderThumbProps };\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}></CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement | null>;\n    itemMap: Map<\n      React.RefObject<ItemElement | null>,\n      { ref: React.RefObject<ItemElement | null> } & ItemData\n    >;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n","import * as React from 'react';\n\nfunction usePrevious<T>(value: T) {\n  const ref = React.useRef({ value, previous: value });\n\n  // We compare values before making an update to ensure that\n  // a change has been made. This ensures the previous value is\n  // persisted correctly between renders.\n  return React.useMemo(() => {\n    if (ref.current.value !== value) {\n      ref.current.previous = ref.current.value;\n      ref.current.value = value;\n    }\n    return ref.current.previous;\n  }, [value]);\n}\n\nexport { usePrevious };\n","import _curry2 from \"./internal/_curry2.js\";\n\n/**\n * Returns a partial copy of an object containing only the keys that satisfy\n * the supplied predicate.\n *\n * @func\n * @memberOf R\n * @since v0.8.0\n * @category Object\n * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}\n * @param {Function} pred A predicate to determine whether or not a key\n *        should be included on the output object.\n * @param {Object} obj The object to copy from\n * @return {Object} A new object with only properties that satisfy `pred`\n *         on it.\n * @see R.pick, R.filter\n * @example\n *\n *      const isUpperCase = (val, key) => key.toUpperCase() === key;\n *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}\n */\nvar pickBy = /*#__PURE__*/_curry2(function pickBy(test, obj) {\n  var result = {};\n  for (var prop in obj) {\n    if (test(obj[prop], prop, obj)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n});\nexport default pickBy;","export default function(x) {\n  return Math.abs(x = Math.round(x)) >= 1e21\n      ? x.toLocaleString(\"en\").replace(/,/g, \"\")\n      : x.toString(10);\n}\n\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimalParts(1.23) returns [\"123\", 0].\nexport function formatDecimalParts(x, p) {\n  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n  var i, coefficient = x.slice(0, i);\n\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x.slice(i + 1)\n  ];\n}\n","// [[fill]align][sign][symbol][0][width][,][.precision][~][type]\nvar re = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\n\nexport default function formatSpecifier(specifier) {\n  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n  var match;\n  return new FormatSpecifier({\n    fill: match[1],\n    align: match[2],\n    sign: match[3],\n    symbol: match[4],\n    zero: match[5],\n    width: match[6],\n    comma: match[7],\n    precision: match[8] && match[8].slice(1),\n    trim: match[9],\n    type: match[10]\n  });\n}\n\nformatSpecifier.prototype = FormatSpecifier.prototype; // instanceof\n\nexport function FormatSpecifier(specifier) {\n  this.fill = specifier.fill === undefined ? \" \" : specifier.fill + \"\";\n  this.align = specifier.align === undefined ? \">\" : specifier.align + \"\";\n  this.sign = specifier.sign === undefined ? \"-\" : specifier.sign + \"\";\n  this.symbol = specifier.symbol === undefined ? \"\" : specifier.symbol + \"\";\n  this.zero = !!specifier.zero;\n  this.width = specifier.width === undefined ? undefined : +specifier.width;\n  this.comma = !!specifier.comma;\n  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;\n  this.trim = !!specifier.trim;\n  this.type = specifier.type === undefined ? \"\" : specifier.type + \"\";\n}\n\nFormatSpecifier.prototype.toString = function() {\n  return this.fill\n      + this.align\n      + this.sign\n      + this.symbol\n      + (this.zero ? \"0\" : \"\")\n      + (this.width === undefined ? \"\" : Math.max(1, this.width | 0))\n      + (this.comma ? \",\" : \"\")\n      + (this.precision === undefined ? \"\" : \".\" + Math.max(0, this.precision | 0))\n      + (this.trim ? \"~\" : \"\")\n      + this.type;\n};\n","import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport var prefixExponent;\n\nexport default function(x, p) {\n  var d = formatDecimalParts(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1],\n      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n      n = coefficient.length;\n  return i === n ? coefficient\n      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n}\n","import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport default function(x, p) {\n  var d = formatDecimalParts(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1];\n  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n}\n","import formatDecimal from \"./formatDecimal.js\";\nimport formatPrefixAuto from \"./formatPrefixAuto.js\";\nimport formatRounded from \"./formatRounded.js\";\n\nexport default {\n  \"%\": function(x, p) { return (x * 100).toFixed(p); },\n  \"b\": function(x) { return Math.round(x).toString(2); },\n  \"c\": function(x) { return x + \"\"; },\n  \"d\": formatDecimal,\n  \"e\": function(x, p) { return x.toExponential(p); },\n  \"f\": function(x, p) { return x.toFixed(p); },\n  \"g\": function(x, p) { return x.toPrecision(p); },\n  \"o\": function(x) { return Math.round(x).toString(8); },\n  \"p\": function(x, p) { return formatRounded(x * 100, p); },\n  \"r\": formatRounded,\n  \"s\": formatPrefixAuto,\n  \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n  \"x\": function(x) { return Math.round(x).toString(16); }\n};\n","export default function(x) {\n  return x;\n}\n","import exponent from \"./exponent.js\";\nimport formatGroup from \"./formatGroup.js\";\nimport formatNumerals from \"./formatNumerals.js\";\nimport formatSpecifier from \"./formatSpecifier.js\";\nimport formatTrim from \"./formatTrim.js\";\nimport formatTypes from \"./formatTypes.js\";\nimport {prefixExponent} from \"./formatPrefixAuto.js\";\nimport identity from \"./identity.js\";\n\nvar map = Array.prototype.map,\n    prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\nexport default function(locale) {\n  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + \"\"),\n      currencyPrefix = locale.currency === undefined ? \"\" : locale.currency[0] + \"\",\n      currencySuffix = locale.currency === undefined ? \"\" : locale.currency[1] + \"\",\n      decimal = locale.decimal === undefined ? \".\" : locale.decimal + \"\",\n      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),\n      percent = locale.percent === undefined ? \"%\" : locale.percent + \"\",\n      minus = locale.minus === undefined ? \"-\" : locale.minus + \"\",\n      nan = locale.nan === undefined ? \"NaN\" : locale.nan + \"\";\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        trim = specifier.trim,\n        type = specifier.type;\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // The \"\" type, and any invalid type, is an alias for \".12~g\".\n    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = \"g\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === \"$\" ? currencyPrefix : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currencySuffix : /[%p]/.test(type) ? percent : \"\";\n\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes[type],\n        maybeSuffix = /[defgprs%]/.test(type);\n\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    precision = precision === undefined ? 6\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n        : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i, n, c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n\n        // Determine the sign. -0 is not less than 0, but 1 / -0 is!\n        var valueNegative = value < 0 || 1 / value < 0;\n\n        // Perform the initial formatting.\n        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);\n\n        // Trim insignificant zeros.\n        if (trim) value = formatTrim(value);\n\n        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.\n        if (valueNegative && +value === 0 && sign !== \"+\") valueNegative = false;\n\n        // Compute the prefix and suffix.\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : minus) : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n        valueSuffix = (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n        // Break the formatted value into the integer value part that can be\n        // grouped, and fractional or exponential suffix part that is not.\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n\n      // If the fill character is not \"0\", grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n      // If the fill character is \"0\", grouping is applied after padding.\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\n        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\n        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\n        default: value = padding + valuePrefix + value + valueSuffix; break;\n      }\n\n      return numerals(value);\n    }\n\n    format.toString = function() {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes[8 + e / 3];\n    return function(value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n}\n","import formatLocale from \"./locale.js\";\n\nvar locale;\nexport var format;\nexport var formatPrefix;\n\ndefaultLocale({\n  decimal: \".\",\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"],\n  minus: \"-\"\n});\n\nexport default function defaultLocale(definition) {\n  locale = formatLocale(definition);\n  format = locale.format;\n  formatPrefix = locale.formatPrefix;\n  return locale;\n}\n","export default function(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length,\n        t = [],\n        j = 0,\n        g = grouping[0],\n        length = 0;\n\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) g = Math.max(1, width - length);\n      t.push(value.substring(i -= g, i + g));\n      if ((length += g + 1) > width) break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n\n    return t.reverse().join(thousands);\n  };\n}\n","export default function(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n}\n","// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.\nexport default function(s) {\n  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {\n    switch (s[i]) {\n      case \".\": i0 = i1 = i; break;\n      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;\n    }\n  }\n  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;\n}\n","import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport default function(x) {\n  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;\n}\n","/* eslint-disable no-magic-numbers */\nimport {pickBy, isEmpty, isNil} from 'ramda';\nimport {formatPrefix} from 'd3-format';\nimport {SliderMarks} from '../types';\n\n/**\n * Truncate marks if they are out of Slider interval\n */\nconst truncateMarks = (\n    min: number,\n    max: number,\n    marks: SliderMarks\n): SliderMarks => pickBy((k, mark) => mark >= min && mark <= max, marks);\n\nconst truncateNumber = (num: number) => {\n    const match = num.toString().match(/^-?\\d+(?:\\.\\d{0,0})?/);\n    return match ? parseInt(match[0], 10) : 0;\n};\n\nconst decimalCount = (d: number) =>\n    String(d).split('.').length > 1 ? String(d).split('.')[1].length : 0;\nconst alignIntValue = (v: number, d: number) =>\n    d < 10\n        ? v\n        : parseInt((truncateNumber(v / d) * d).toFixed(decimalCount(d)), 10);\nconst alignDecimalValue = (v: number, d: number) =>\n    d < 10\n        ? parseFloat(v.toFixed(decimalCount(d)))\n        : parseFloat(\n              (parseFloat((v / d).toFixed(0)) * d).toFixed(decimalCount(d))\n          );\n\nconst alignValue = (v: number, d: number) =>\n    decimalCount(d) < 1 ? alignIntValue(v, d) : alignDecimalValue(v, d);\n\nexport const applyD3Format = (mark: number, min: number, max: number) => {\n    const mu_ten_factor = -3;\n    const k_ten_factor = 4; // values < 10000 don't get formatted\n\n    const ten_factor = Math.log10(Math.abs(mark));\n    if (\n        mark === 0 ||\n        (ten_factor > mu_ten_factor && ten_factor < k_ten_factor)\n    ) {\n        return String(mark);\n    }\n    const max_min_mean = (Math.abs(max) + Math.abs(min)) / 2;\n    const si_formatter = formatPrefix(',.0', max_min_mean);\n    return String(si_formatter(mark));\n};\n\nconst estimateBestSteps = (\n    minValue: number,\n    maxValue: number,\n    stepValue: number,\n    sliderWidth?: number | null\n) => {\n    // Use formatted label length to account for SI formatting\n    // (e.g. labels that look like \"100M\" vs \"100000000\")\n    const formattedMin = applyD3Format(minValue, minValue, maxValue);\n    const formattedMax = applyD3Format(maxValue, minValue, maxValue);\n    const maxValueChars = Math.max(formattedMin.length, formattedMax.length);\n\n    // Calculate required spacing based on label width\n    // Estimate: 10px per character + 20px margin for spacing between labels\n    // This provides comfortable spacing to prevent overlap\n    const pixelsPerChar = 10;\n    const spacingMargin = 20;\n    const minPixelsPerMark = maxValueChars * pixelsPerChar + spacingMargin;\n\n    const effectiveWidth = sliderWidth || 330;\n\n    // Calculate maximum number of marks that can fit without overlap\n    let targetMarkCount = Math.floor(effectiveWidth / minPixelsPerMark) + 1;\n    targetMarkCount = Math.max(3, Math.min(targetMarkCount, 50));\n\n    // Calculate the ideal interval between marks based on target count\n    const range = maxValue - minValue;\n    const idealInterval = range / (targetMarkCount - 1);\n\n    // Calculate the multiplier needed to get close to idealInterval\n    // Round to a \"nice\" number for cleaner mark placement\n    const rawMultiplier = idealInterval / stepValue;\n\n    // Round to nearest nice multiplier (1, 2, 2.5, 5, or power of 10 multiple)\n    const magnitude = Math.pow(10, Math.floor(Math.log10(rawMultiplier)));\n    const normalized = rawMultiplier / magnitude; // Now between 1 and 10\n\n    let niceMultiplier;\n    if (normalized <= 1.5) {\n        niceMultiplier = 1;\n    } else if (normalized <= 2.25) {\n        niceMultiplier = 2;\n    } else if (normalized <= 3.5) {\n        niceMultiplier = 2.5;\n    } else if (normalized <= 5) {\n        niceMultiplier = 5;\n    } else {\n        niceMultiplier = 10;\n    }\n\n    const bestMultiplier = Math.max(1, niceMultiplier * magnitude);\n    const bestInterval = stepValue * bestMultiplier;\n\n    // All marks must be at valid step positions: minValue + (n * stepValue)\n    // Find the first mark after minValue that fits our desired interval\n    const stepsInInterval = Math.round(bestInterval / stepValue);\n    const actualInterval = stepsInInterval * stepValue;\n\n    // Find the first mark position that's aligned with our interval\n    // This ensures we don't have overlapping marks at narrow widths\n    const firstMarkSteps = Math.max(1, stepsInInterval);\n    const firstStepAfterMin = minValue + firstMarkSteps * stepValue;\n\n    return [firstStepAfterMin, actualInterval, stepValue];\n};\n\n/**\n * Calculate default step if not defined\n */\nexport const calcStep = (min?: number, max?: number, step?: number | null) => {\n    if (step) {\n        return step;\n    }\n\n    if (isNil(min) || isNil(max)) {\n        return 1;\n    }\n\n    const diff = max > min ? max - min : min - max;\n\n    const v = (Math.abs(diff) + Number.EPSILON) / 100;\n    const N = Math.floor(Math.log10(v));\n    return [\n        Number(Math.pow(10, N)),\n        2 * Math.pow(10, N),\n        5 * Math.pow(10, N),\n    ].sort((a, b) => Math.abs(a - v) - Math.abs(b - v))[0];\n};\n\n/**\n * Set min and max if they are undefined and marks are defined\n */\nexport const setUndefined = (\n    min: number | undefined,\n    max: number | undefined,\n    marks: SliderMarks | undefined | null\n) => {\n    const definedMarks = {min_mark: min ?? 0, max_mark: max ?? 1};\n\n    if (isNil(marks)) {\n        return definedMarks;\n    }\n\n    const marksObject = Object.keys(marks).map(Number);\n\n    if (isNil(min)) {\n        definedMarks.min_mark = Math.min(...marksObject);\n    }\n\n    if (isNil(max)) {\n        definedMarks.max_mark = Math.max(...marksObject);\n    }\n\n    return definedMarks;\n};\n\nexport const autoGenerateMarks = (\n    min: number,\n    max: number,\n    step?: number | null,\n    sliderWidth?: number | null\n) => {\n    const marks = [];\n\n    const effectiveStep = step ?? 1;\n\n    const [start, interval, chosenStep] = estimateBestSteps(\n        min,\n        max,\n        effectiveStep,\n        sliderWidth\n    );\n    let cursor = start;\n\n    if ((max - cursor) / interval > 0) {\n        while (cursor < max) {\n            marks.push(alignValue(cursor, chosenStep));\n            const prevCursor = cursor;\n            cursor += interval;\n\n            // Safety check: floating point precision could impact this loop\n            if (cursor <= prevCursor) {\n                break;\n            }\n        }\n\n        const discardThreshold = 1.5;\n        if (\n            marks.length >= 2 &&\n            max - marks[marks.length - 2] <= interval * discardThreshold\n        ) {\n            marks.pop();\n        }\n    }\n    const marksObject: SliderMarks = {};\n    marks.forEach(mark => {\n        marksObject[mark] = applyD3Format(mark, min, max);\n    });\n    marksObject[min] = applyD3Format(min, min, max);\n    marksObject[max] = applyD3Format(max, min, max);\n    return marksObject;\n};\n\n/**\n * - Auto generate marks if not given,\n * - Not generate anything at all when explicit null is given to marks\n * - Then truncate marks so no out of range marks\n */\ntype SanitizeMarksParams = {\n    min?: number;\n    max?: number;\n    marks?: SliderMarks;\n    step?: number | null;\n    sliderWidth?: number | null;\n};\nexport const sanitizeMarks = ({\n    min,\n    max,\n    marks,\n    step,\n    sliderWidth,\n}: SanitizeMarksParams): SliderMarks => {\n    const {min_mark, max_mark} = setUndefined(min, max, marks);\n\n    const truncated_marks =\n        marks && isEmpty(marks) === false\n            ? truncateMarks(min_mark, max_mark, marks)\n            : marks;\n\n    if (truncated_marks && isEmpty(truncated_marks) === false) {\n        return truncated_marks;\n    }\n\n    return autoGenerateMarks(min_mark, max_mark, step, sliderWidth);\n};\n\n/**\n * Calculate default value if not defined\n */\nexport const calcValue = (min: number, max: number, value: unknown) => {\n    if (value !== undefined) {\n        return value;\n    }\n\n    return [min, max];\n};\n","import {SliderMarks} from '../types';\n\nexport const snapToNearestMark = (\n    value: number,\n    marks: SliderMarks\n): number => {\n    const markValues = Object.keys(marks).map(Number);\n    if (markValues.length === 0) {\n        return value;\n    }\n\n    return markValues.reduce((closest, current) => {\n        return Math.abs(current - value) < Math.abs(closest - value)\n            ? current\n            : closest;\n    });\n};\n","import React from 'react';\nimport {SliderMarks} from '../types';\n\n// Replicate Radix UI's exact positioning logic for displaying marks\nconst convertValueToPercentage = (value: number, min: number, max: number) => {\n    const maxSteps = max - min;\n    const percentPerStep = 100 / maxSteps;\n    const percentage = percentPerStep * (value - min);\n    // Clamp to 0-100 range like Radix does\n    return Math.max(0, Math.min(100, percentage));\n};\n\nconst linearScale = (\n    input: readonly [number, number],\n    output: readonly [number, number]\n) => {\n    return (value: number) => {\n        if (input[0] === input[1] || output[0] === output[1]) {\n            return output[0];\n        }\n        const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n        return output[0] + ratio * (value - input[0]);\n    };\n};\n\nconst getThumbInBoundsOffset = (\n    width: number,\n    left: number,\n    direction: number\n) => {\n    const halfWidth = width / 2;\n    const halfPercent = 50;\n    const offset = linearScale([0, halfPercent], [0, halfWidth]);\n    return (halfWidth - offset(left) * direction) * direction;\n};\n\n// Calculate the exact position including pixel offset as Radix does\nconst getRadixThumbPosition = (\n    value: number,\n    minMaxValues: {min_mark: number; max_mark: number},\n    thumbWidth = 16\n) => {\n    const percentage = convertValueToPercentage(\n        value,\n        minMaxValues.min_mark,\n        minMaxValues.max_mark\n    );\n    const direction = 1; // LTR direction\n    const thumbInBoundsOffset = getThumbInBoundsOffset(\n        thumbWidth,\n        percentage,\n        direction\n    );\n    return {percentage, offset: thumbInBoundsOffset};\n};\n\nexport const renderSliderMarks = (\n    renderedMarks: SliderMarks,\n    vertical: boolean,\n    minMaxValues: {min_mark: number; max_mark: number},\n    selectedValues: number[] = [],\n    dots: boolean,\n    reverse = false\n) => {\n    return Object.entries(renderedMarks).map(([position, mark]) => {\n        const pos = parseFloat(position);\n\n        // When reversed, use the inverted value for positioning\n        const displayPos = reverse\n            ? minMaxValues.max_mark - pos + minMaxValues.min_mark\n            : pos;\n\n        const thumbPosition = getRadixThumbPosition(displayPos, minMaxValues);\n\n        const style = vertical\n            ? {\n                  bottom: `calc(${thumbPosition.percentage}% + ${thumbPosition.offset}px - 13px)`,\n                  left: 'calc(100% + 8px)',\n                  transform: 'translateY(-50%)',\n              }\n            : {\n                  left: `calc(${thumbPosition.percentage}% + ${thumbPosition.offset}px)`,\n                  bottom: 0,\n                  transform: 'translateX(-50%)',\n              };\n\n        // Determine if mark is outside the selected range\n        let isOutsideSelection = false;\n        if (selectedValues.length === 1) {\n            isOutsideSelection = pos > selectedValues[0];\n        } else if (selectedValues.length > 1) {\n            const [minValue, maxValue] = [\n                selectedValues[0],\n                selectedValues[selectedValues.length - 1],\n            ];\n            isOutsideSelection = pos < minValue || pos > maxValue;\n        }\n\n        const outsideClassName = isOutsideSelection\n            ? 'dash-slider-mark-outside-selection'\n            : '';\n\n        const className = `dash-slider-mark ${\n            dots ? 'with-dots' : ''\n        } ${outsideClassName}`.trim();\n\n        return (\n            <div\n                key={position}\n                className={className}\n                style={{\n                    ...style,\n                    ...(typeof mark === 'object' && mark.style\n                        ? mark.style\n                        : {}),\n                }}\n            >\n                {typeof mark === 'string' ? mark : mark?.label || pos}\n            </div>\n        );\n    });\n};\n\nexport const renderSliderDots = (\n    stepValue: number,\n    minMaxValues: {min_mark: number; max_mark: number},\n    selectedValues: number[] = [],\n    vertical: boolean,\n    reverse = false\n) => {\n    if (stepValue <= 1) {\n        return null;\n    }\n\n    const dotCount =\n        Math.floor(\n            (minMaxValues.max_mark - minMaxValues.min_mark) / stepValue\n        ) + 1;\n\n    // Cap at 100 dots - if more, don't render any dots\n    if (dotCount > 100) {\n        return null;\n    }\n\n    return Array.from(\n        {\n            length: dotCount,\n        },\n        (_, i) => {\n            const dotValue = minMaxValues.min_mark + i * stepValue;\n\n            // When reversed, use the inverted value for positioning\n            const displayValue = reverse\n                ? minMaxValues.max_mark - dotValue + minMaxValues.min_mark\n                : dotValue;\n\n            const thumbPosition = getRadixThumbPosition(\n                displayValue,\n                minMaxValues\n            );\n\n            const dotStyle = vertical\n                ? {\n                      bottom: `calc(${thumbPosition.percentage}% + ${thumbPosition.offset}px)`,\n                      left: '2px',\n                      transform: 'translate(50%, 50%)',\n                  }\n                : {\n                      left: `calc(${thumbPosition.percentage}% + ${thumbPosition.offset}px)`,\n                      top: '0',\n                      transform: 'translate(-50%, 50%)',\n                  };\n\n            // Determine if dot is outside the selected range\n            let isOutsideSelection = false;\n            if (selectedValues.length === 1) {\n                isOutsideSelection = dotValue > selectedValues[0];\n            } else if (selectedValues.length > 1) {\n                const [minValue, maxValue] = [\n                    selectedValues[0],\n                    selectedValues[selectedValues.length - 1],\n                ];\n                isOutsideSelection = dotValue < minValue || dotValue > maxValue;\n            }\n\n            const className = isOutsideSelection\n                ? 'dash-slider-dot dash-slider-dot-outside-selection'\n                : 'dash-slider-dot';\n\n            return (\n                <div\n                    key={i}\n                    className={className}\n                    style={{\n                        ...dotStyle,\n                    }}\n                />\n            );\n        }\n    );\n};\n","import _curry3 from \"./internal/_curry3.js\";\n\n/**\n * Replace a substring or regex match in a string with a replacement.\n *\n * The first two parameters correspond to the parameters of the\n * `String.prototype.replace()` function, so the second parameter can also be a\n * function.\n *\n * @func\n * @memberOf R\n * @since v0.7.0\n * @category String\n * @sig RegExp|String -> String -> String -> String\n * @param {RegExp|String} pattern A regular expression or a substring to match.\n * @param {String} replacement The string to replace the matches with.\n * @param {String} str The String to do the search and replacement in.\n * @return {String} The result.\n * @example\n *\n *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'\n *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'\n *\n *      // Use the \"g\" (global) flag to replace all occurrences:\n *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'\n */\nvar replace = /*#__PURE__*/_curry3(function replace(regex, replacement, str) {\n  return str.replace(regex, replacement);\n});\nexport default replace;","export default function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0:\n      return function () {\n        return fn.apply(this, arguments);\n      };\n    case 1:\n      return function (a0) {\n        return fn.apply(this, arguments);\n      };\n    case 2:\n      return function (a0, a1) {\n        return fn.apply(this, arguments);\n      };\n    case 3:\n      return function (a0, a1, a2) {\n        return fn.apply(this, arguments);\n      };\n    case 4:\n      return function (a0, a1, a2, a3) {\n        return fn.apply(this, arguments);\n      };\n    case 5:\n      return function (a0, a1, a2, a3, a4) {\n        return fn.apply(this, arguments);\n      };\n    case 6:\n      return function (a0, a1, a2, a3, a4, a5) {\n        return fn.apply(this, arguments);\n      };\n    case 7:\n      return function (a0, a1, a2, a3, a4, a5, a6) {\n        return fn.apply(this, arguments);\n      };\n    case 8:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n        return fn.apply(this, arguments);\n      };\n    case 9:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n        return fn.apply(this, arguments);\n      };\n    case 10:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n        return fn.apply(this, arguments);\n      };\n    default:\n      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n}","export default function _pipe(f, g) {\n  return function () {\n    return g.call(this, f.apply(this, arguments));\n  };\n}","import _curry1 from \"./_curry1.js\";\nimport _isArray from \"./_isArray.js\";\nimport _isString from \"./_isString.js\";\n\n/**\n * Tests whether or not an object is similar to an array.\n *\n * @private\n * @category Type\n * @category List\n * @sig * -> Boolean\n * @param {*} x The object to test.\n * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n * @example\n *\n *      _isArrayLike([]); //=> true\n *      _isArrayLike(true); //=> false\n *      _isArrayLike({}); //=> false\n *      _isArrayLike({length: 10}); //=> false\n *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n *      _isArrayLike({nodeType: 1, length: 1}) // => false\n */\nvar _isArrayLike = /*#__PURE__*/_curry1(function isArrayLike(x) {\n  if (_isArray(x)) {\n    return true;\n  }\n  if (!x) {\n    return false;\n  }\n  if (typeof x !== 'object') {\n    return false;\n  }\n  if (_isString(x)) {\n    return false;\n  }\n  if (x.length === 0) {\n    return true;\n  }\n  if (x.length > 0) {\n    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n  }\n  return false;\n});\nexport default _isArrayLike;","import _isArrayLike from \"./_isArrayLike.js\";\nvar symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\nexport default function _createReduce(arrayReduce, methodReduce, iterableReduce) {\n  return function _reduce(xf, acc, list) {\n    if (_isArrayLike(list)) {\n      return arrayReduce(xf, acc, list);\n    }\n    if (list == null) {\n      return acc;\n    }\n    if (typeof list['fantasy-land/reduce'] === 'function') {\n      return methodReduce(xf, acc, list, 'fantasy-land/reduce');\n    }\n    if (list[symIterator] != null) {\n      return iterableReduce(xf, acc, list[symIterator]());\n    }\n    if (typeof list.next === 'function') {\n      return iterableReduce(xf, acc, list);\n    }\n    if (typeof list.reduce === 'function') {\n      return methodReduce(xf, acc, list, 'reduce');\n    }\n    throw new TypeError('reduce: list must be array or iterable');\n  };\n}","export default function _xArrayReduce(xf, acc, list) {\n  var idx = 0;\n  var len = list.length;\n  while (idx < len) {\n    acc = xf['@@transducer/step'](acc, list[idx]);\n    if (acc && acc['@@transducer/reduced']) {\n      acc = acc['@@transducer/value'];\n      break;\n    }\n    idx += 1;\n  }\n  return xf['@@transducer/result'](acc);\n}","import _arity from \"./internal/_arity.js\";\nimport _curry2 from \"./internal/_curry2.js\";\n\n/**\n * Creates a function that is bound to a context.\n * Note: `R.bind` does not provide the additional argument-binding capabilities of\n * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n *\n * @func\n * @memberOf R\n * @since v0.6.0\n * @category Function\n * @category Object\n * @sig (* -> *) -> {*} -> (* -> *)\n * @param {Function} fn The function to bind to context\n * @param {Object} thisObj The context to bind `fn` to\n * @return {Function} A function that will execute in the context of `thisObj`.\n * @see R.partial\n * @example\n *\n *      const log = R.bind(console.log, console);\n *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}\n *      // logs {a: 2}\n * @symb R.bind(f, o)(a, b) = f.call(o, a, b)\n */\nvar bind = /*#__PURE__*/_curry2(function bind(fn, thisObj) {\n  return _arity(fn.length, function () {\n    return fn.apply(thisObj, arguments);\n  });\n});\nexport default bind;","import _createReduce from \"./_createReduce.js\";\nimport _xArrayReduce from \"./_xArrayReduce.js\";\nimport bind from \"../bind.js\";\nfunction _xIterableReduce(xf, acc, iter) {\n  var step = iter.next();\n  while (!step.done) {\n    acc = xf['@@transducer/step'](acc, step.value);\n    if (acc && acc['@@transducer/reduced']) {\n      acc = acc['@@transducer/value'];\n      break;\n    }\n    step = iter.next();\n  }\n  return xf['@@transducer/result'](acc);\n}\nfunction _xMethodReduce(xf, acc, obj, methodName) {\n  return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));\n}\nvar _xReduce = /*#__PURE__*/_createReduce(_xArrayReduce, _xMethodReduce, _xIterableReduce);\nexport default _xReduce;","var XWrap = /*#__PURE__*/function () {\n  function XWrap(fn) {\n    this.f = fn;\n  }\n  XWrap.prototype['@@transducer/init'] = function () {\n    throw new Error('init not implemented on XWrap');\n  };\n  XWrap.prototype['@@transducer/result'] = function (acc) {\n    return acc;\n  };\n  XWrap.prototype['@@transducer/step'] = function (acc, x) {\n    return this.f(acc, x);\n  };\n  return XWrap;\n}();\nexport default function _xwrap(fn) {\n  return new XWrap(fn);\n}","import _curry3 from \"./internal/_curry3.js\";\nimport _xReduce from \"./internal/_xReduce.js\";\nimport _xwrap from \"./internal/_xwrap.js\";\n\n/**\n * Returns a single item by iterating through the list, successively calling\n * the iterator function and passing it an accumulator value and the current\n * value from the array, and then passing the result to the next call.\n *\n * The iterator function receives two values: *(acc, value)*. It may use\n * [`R.reduced`](#reduced) to shortcut the iteration.\n *\n * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function\n * is *(value, acc)*.\n *\n * Note: `R.reduce` does not skip deleted or unassigned indices (sparse\n * arrays), unlike the native `Array.prototype.reduce` method. For more details\n * on this behavior, see:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\n *\n * Be cautious of mutating and returning the accumulator. If you reuse it across\n * invocations, it will continue to accumulate onto the same value. The general\n * recommendation is to always return a new value. If you can't do so for\n * performance reasons, then be sure to reinitialize the accumulator on each\n * invocation.\n *\n * Dispatches to the `reduce` method of the third argument, if present. When\n * doing so, it is up to the user to handle the [`R.reduced`](#reduced)\n * shortcuting, as this is not implemented by `reduce`.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig ((a, b) -> a) -> a -> [b] -> a\n * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n *        current element from the array.\n * @param {*} acc The accumulator value.\n * @param {Array} list The list to iterate over.\n * @return {*} The final, accumulated value.\n * @see R.reduced, R.addIndex, R.reduceRight\n * @example\n *\n *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10\n *      //          -               -10\n *      //         / \\              / \\\n *      //        -   4           -6   4\n *      //       / \\              / \\\n *      //      -   3   ==>     -3   3\n *      //     / \\              / \\\n *      //    -   2           -1   2\n *      //   / \\              / \\\n *      //  0   1            0   1\n *\n * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)\n */\nvar reduce = /*#__PURE__*/_curry3(function (xf, acc, list) {\n  return _xReduce(typeof xf === 'function' ? _xwrap(xf) : xf, acc, list);\n});\nexport default reduce;","import _isArray from \"./_isArray.js\";\n\n/**\n * This checks whether a function has a [methodname] function. If it isn't an\n * array it will execute that function otherwise it will default to the ramda\n * implementation.\n *\n * @private\n * @param {Function} fn ramda implementation\n * @param {String} methodname property to check for a custom implementation\n * @return {Object} Whatever the return value of the method is.\n */\nexport default function _checkForMethod(methodname, fn) {\n  return function () {\n    var length = arguments.length;\n    if (length === 0) {\n      return fn();\n    }\n    var obj = arguments[length - 1];\n    return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));\n  };\n}","import _checkForMethod from \"./internal/_checkForMethod.js\";\nimport _curry3 from \"./internal/_curry3.js\";\n\n/**\n * Returns the elements of the given list or string (or object with a `slice`\n * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).\n *\n * Dispatches to the `slice` method of the third argument, if present.\n *\n * @func\n * @memberOf R\n * @since v0.1.4\n * @category List\n * @sig Number -> Number -> [a] -> [a]\n * @sig Number -> Number -> String -> String\n * @param {Number} fromIndex The start index (inclusive).\n * @param {Number} toIndex The end index (exclusive).\n * @param {*} list\n * @return {*}\n * @example\n *\n *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']\n *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']\n *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']\n *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']\n *      R.slice(0, 3, 'ramda');                     //=> 'ram'\n */\nvar slice = /*#__PURE__*/_curry3( /*#__PURE__*/_checkForMethod('slice', function slice(fromIndex, toIndex, list) {\n  return Array.prototype.slice.call(list, fromIndex, toIndex);\n}));\nexport default slice;","import _checkForMethod from \"./internal/_checkForMethod.js\";\nimport _curry1 from \"./internal/_curry1.js\";\nimport slice from \"./slice.js\";\n\n/**\n * Returns all but the first element of the given list or string (or object\n * with a `tail` method).\n *\n * Dispatches to the `slice` method of the first argument, if present.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig [a] -> [a]\n * @sig String -> String\n * @param {*} list\n * @return {*}\n * @see R.head, R.init, R.last\n * @example\n *\n *      R.tail([1, 2, 3]);  //=> [2, 3]\n *      R.tail([1, 2]);     //=> [2]\n *      R.tail([1]);        //=> []\n *      R.tail([]);         //=> []\n *\n *      R.tail('abc');  //=> 'bc'\n *      R.tail('ab');   //=> 'b'\n *      R.tail('a');    //=> ''\n *      R.tail('');     //=> ''\n */\nvar tail = /*#__PURE__*/_curry1( /*#__PURE__*/_checkForMethod('tail', /*#__PURE__*/slice(1, Infinity)));\nexport default tail;","import _arity from \"./_arity.js\";\nimport _isPlaceholder from \"./_isPlaceholder.js\";\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nexport default function _curryN(length, received, fn) {\n  return function () {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    var hasPlaceholder = false;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      } else {\n        hasPlaceholder = true;\n      }\n      combinedIdx += 1;\n    }\n    return !hasPlaceholder && left <= 0 ? fn.apply(this, combined) : _arity(Math.max(0, left), _curryN(length, combined, fn));\n  };\n}","import _arity from \"./internal/_arity.js\";\nimport _curry1 from \"./internal/_curry1.js\";\nimport _curry2 from \"./internal/_curry2.js\";\nimport _curryN from \"./internal/_curryN.js\";\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      const sumArgs = (...args) => R.sum(args);\n *\n *      const curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      const f = curriedAddFourNumbers(1, 2);\n *      const g = f(3);\n *      g(4); //=> 10\n */\nvar curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\nexport default curryN;","import _curry2 from \"./internal/_curry2.js\";\nimport _isFunction from \"./internal/_isFunction.js\";\nimport curryN from \"./curryN.js\";\nimport toString from \"./toString.js\";\n\n/**\n * Given an `arity` (Number) and a `name` (String) the `invoker` function\n * returns a curried function that takes `arity` arguments and a `context`\n * object. It will \"invoke\" the `name`'d function (a method) on the `context`\n * object.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)\n * @param {Number} arity Number of arguments the returned function should take\n *        before the target object.\n * @param {String} method Name of any of the target object's methods to call.\n * @return {Function} A new curried function.\n * @see R.construct\n * @example\n *      // A function with no arguments\n *      const asJson = invoker(0, \"json\")\n *      // Just like calling .then((response) => response.json())\n *      fetch(\"http://example.com/index.json\").then(asJson)\n *\n *      // A function with one argument\n *      const sliceFrom = invoker(1, 'slice');\n *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'\n *\n *      // A function with two arguments\n *      const sliceFrom6 = invoker(2, 'slice')(6);\n *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'\n *\n *      // NOTE: You can't simply pass some of the arguments to the initial invoker function.\n *      const firstCreditCardSection = invoker(2, \"slice\", 0, 4)\n *      firstCreditCardSection(\"4242 4242 4242 4242\") // => Function<...>\n *\n *      // Since invoker returns a curried function, you may partially apply it to create the function you need.\n *      const firstCreditCardSection = invoker(2, \"slice\")(0, 4)\n *      firstCreditCardSection(\"4242 4242 4242 4242\") // => \"4242\"\n *\n * @symb R.invoker(0, 'method')(o) = o['method']()\n * @symb R.invoker(1, 'method')(a, o) = o['method'](a)\n * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)\n */\nvar invoker = /*#__PURE__*/_curry2(function invoker(arity, method) {\n  return curryN(arity + 1, function () {\n    var target = arguments[arity];\n    if (target != null && _isFunction(target[method])) {\n      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));\n    }\n    throw new TypeError(toString(target) + ' does not have a method named \"' + method + '\"');\n  });\n});\nexport default invoker;","import invoker from \"./invoker.js\";\n\n/**\n * Splits a string into an array of strings based on the given\n * separator.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category String\n * @sig (String | RegExp) -> String -> [String]\n * @param {String|RegExp} sep The pattern.\n * @param {String} str The string to separate into an array.\n * @return {Array} The array of strings from `str` separated by `sep`.\n * @see R.join\n * @example\n *\n *      const pathComponents = R.split('/');\n *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']\n *\n *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']\n */\nvar split = /*#__PURE__*/invoker(1, 'split');\nexport default split;","/**\n * Determine if the passed argument is an integer.\n *\n * @private\n * @param {*} n\n * @category Type\n * @return {Boolean}\n */\nexport default Number.isInteger || function _isInteger(n) {\n  return n << 0 === n;\n};","import _isString from \"./_isString.js\";\nexport default function _nth(offset, list) {\n  var idx = offset < 0 ? list.length + offset : offset;\n  return _isString(list) ? list.charAt(idx) : list[idx];\n}","import _isInteger from \"./_isInteger.js\";\nimport _nth from \"./_nth.js\";\nexport default function _path(pathAr, obj) {\n  var val = obj;\n  for (var i = 0; i < pathAr.length; i += 1) {\n    if (val == null) {\n      return undefined;\n    }\n    var p = pathAr[i];\n    if (_isInteger(p)) {\n      val = _nth(p, val);\n    } else {\n      val = val[p];\n    }\n  }\n  return val;\n}","import _curry2 from \"./internal/_curry2.js\";\nimport _path from \"./internal/_path.js\";\n\n/**\n * Retrieves the value at a given path. The nodes of the path can be arbitrary strings or non-negative integers.\n * For anything else, the value is unspecified. Integer paths are meant to index arrays, strings are meant for objects.\n *\n * @func\n * @memberOf R\n * @since v0.2.0\n * @category Object\n * @typedefn Idx = String | Int | Symbol\n * @sig [Idx] -> {a} -> a | Undefined\n * @sig Idx = String | NonNegativeInt\n * @param {Array} path The path to use.\n * @param {Object} obj The object or array to retrieve the nested property from.\n * @return {*} The data at `path`.\n * @see R.prop, R.nth, R.assocPath, R.dissocPath\n * @example\n *\n *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2\n *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined\n *      R.path(['a', 'b', 0], {a: {b: [1, 2, 3]}}); //=> 1\n *      R.path(['a', 'b', -2], {a: {b: [1, 2, 3]}}); //=> 2\n *      R.path([2], {'2': 2}); //=> 2\n *      R.path([-2], {'-2': 'a'}); //=> undefined\n */\n\nvar path = /*#__PURE__*/_curry2(_path);\nexport default path;","import React from 'react';\nimport {\n    formatSliderTooltip,\n    transformSliderTooltip,\n} from '../utils/formatSliderTooltip';\nimport {SliderTooltip} from '../types';\n\ntype TooltipProps = {\n    id?: string;\n    index: number;\n    value: number;\n    tooltip: SliderTooltip;\n};\n\nexport const Tooltip = ({tooltip, value, index: key, id}: TooltipProps) => {\n    const formatTooltipContent = (value: number, index: number) => {\n        let displayValue: string | number = value;\n        if (tooltip?.transform) {\n            displayValue = transformSliderTooltip(tooltip.transform, value);\n        }\n        return (\n            <div\n                id={`${id}-tooltip-${index + 1}-content`}\n                style={tooltip?.style}\n            >\n                {formatSliderTooltip(\n                    tooltip?.template || '{value}',\n                    displayValue\n                )}\n            </div>\n        );\n    };\n\n    const classNames = [\n        'dash-slider-tooltip',\n        tooltip.always_visible ? 'always-visible' : '',\n    ];\n\n    const placement = (tooltip.placement ?? 'top').toLowerCase();\n    const position: React.CSSProperties = {transform: ''};\n\n    if (placement.includes('top')) {\n        position.bottom = 'calc(100% + var(--Dash-Spacing))';\n    } else if (placement.includes('bottom')) {\n        position.top = 'calc(100% + var(--Dash-Spacing))';\n    } else {\n        position.top = '50%';\n        position.transform += 'translateY(-50%)';\n    }\n\n    if (placement.includes('left')) {\n        position.right = 'calc(100% + var(--Dash-Spacing))';\n    } else if (placement.includes('right')) {\n        position.left = 'calc(100% + var(--Dash-Spacing))';\n    } else {\n        position.left = '50%';\n        position.transform += 'translateX(-50%)';\n    }\n\n    return (\n        <div className={classNames.join(' ')} style={position}>\n            {formatTooltipContent(value, key)}\n        </div>\n    );\n};\n","import {replace, path, split, concat, pipe} from 'ramda';\n\nexport const formatSliderTooltip = (template: string, value: string | number) => {\n    return replace('{value}', `${value}`, template);\n};\n\nexport const transformSliderTooltip = (funcName: string, value: string | number) => {\n    type TransformFunc = (value: string | number) => string | number;\n    const func = pipe(\n        split('.'),\n        s => concat(['dccFunctions'], s),\n        s => path(s, window)\n    )(funcName) as TransformFunc;\n    if (!func) {\n        throw new Error(\n            `Invalid func for slider tooltip transform: ${funcName}`\n        );\n    }\n    return func(value);\n};\n","import _arity from \"./internal/_arity.js\";\nimport _pipe from \"./internal/_pipe.js\";\nimport reduce from \"./reduce.js\";\nimport tail from \"./tail.js\";\n\n/**\n * Performs left-to-right function composition. The first argument may have\n * any arity; the remaining arguments must be unary.\n *\n * In some libraries this function is named `sequence`.\n *\n * **Note:** The result of pipe is not automatically curried.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)\n * @param {...Function} functions\n * @return {Function}\n * @see R.compose\n * @example\n *\n *      const f = R.pipe(Math.pow, R.negate, R.inc);\n *\n *      f(3, 4); // -(3^4) + 1\n * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))\n * @symb R.pipe(f, g, h)(a)(b) = h(g(f(a)))(b)\n */\nexport default function pipe() {\n  if (arguments.length === 0) {\n    throw new Error('pipe requires at least one argument');\n  }\n  return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));\n}","import React, {useEffect, useState, useMemo, useRef} from 'react';\nimport * as RadixSlider from '@radix-ui/react-slider';\nimport {isNil} from 'ramda';\n\nimport {\n    sanitizeMarks,\n    calcStep,\n    setUndefined,\n} from '../utils/computeSliderMarkers';\nimport {snapToNearestMark} from '../utils/sliderSnapToMark';\nimport {renderSliderMarks, renderSliderDots} from '../utils/sliderRendering';\nimport LoadingElement from '../utils/_LoadingElement';\nimport {Tooltip} from '../utils/sliderTooltip';\nimport {RangeSliderProps} from '../types';\n\nconst MAX_MARKS = 500;\n\n/**\n * A double slider with two handles.\n * Used for specifying a range of numerical values.\n */\nexport default function RangeSlider(props: RangeSliderProps) {\n    const {\n        className,\n        id,\n        setProps,\n        tooltip,\n        updatemode,\n        min,\n        max,\n        marks,\n        step,\n        vertical,\n        verticalHeight,\n        value: propValue,\n        disabled,\n        dots,\n        included,\n        allowCross,\n        pushable,\n        count,\n        reverse,\n        allow_direct_input = true,\n    } = props;\n\n    // For range slider, we expect an array of values\n    const [value, setValue] = useState<number[]>(propValue || []);\n\n    // Track slider dimension (width for horizontal, height for vertical) for marks rendering\n    const [sliderWidth, setSliderWidth] = useState<number | null>(null);\n\n    const sliderRef = useRef<HTMLDivElement>(null);\n    const inputRef = useRef<HTMLInputElement>(null);\n\n    // Handle initial mount - equivalent to componentWillMount\n    useEffect(() => {\n        if (propValue && propValue.length > 0) {\n            setProps({drag_value: propValue});\n            setValue(propValue);\n        } else {\n            // Default to range from min to max if no value provided\n            const defaultValue = [min ?? (propValue ? propValue[0] : 0)];\n            setValue(defaultValue);\n        }\n    }, []);\n\n    // Dynamic dimension detection using ResizeObserver for marks rendering\n    useEffect(() => {\n        if (!sliderRef.current) {\n            return;\n        }\n\n        const measureWidth = () => {\n            if (sliderRef.current) {\n                const rect = sliderRef.current.getBoundingClientRect();\n                // Use height for vertical sliders, width for horizontal sliders\n                const dimension = vertical ? rect.height : rect.width;\n                if (dimension > 0) {\n                    setSliderWidth(dimension);\n                }\n            }\n        };\n\n        // Initial measurement\n        measureWidth();\n\n        // Set up ResizeObserver for dynamic resizing\n        const resizeObserver = new ResizeObserver(() => {\n            measureWidth();\n        });\n\n        resizeObserver.observe(sliderRef.current);\n\n        // Cleanup function when component unmounts\n        // eslint-disable-next-line consistent-return\n        return () => {\n            resizeObserver.disconnect();\n        };\n    }, [vertical]);\n\n    // Handle prop value changes - equivalent to componentWillReceiveProps\n    useEffect(() => {\n        if (propValue && JSON.stringify(propValue) !== JSON.stringify(value)) {\n            setProps({drag_value: propValue});\n            setValue(propValue);\n        }\n    }, [propValue]);\n\n    // Check if marks exceed 500 limit for performance\n    let processedMarks = marks;\n    if (marks && typeof marks === 'object' && marks !== null) {\n        const marksCount = Object.keys(marks).length;\n        if (marksCount > MAX_MARKS) {\n            /* eslint-disable no-console */\n            console.error(\n                `Slider: Too many marks (${marksCount}) provided. ` +\n                    `For performance reasons, marks are limited to 500. ` +\n                    `Using auto-generated marks instead.`\n            );\n            processedMarks = undefined;\n        }\n    }\n\n    const minMaxValues = useMemo(() => {\n        return setUndefined(min, max, processedMarks);\n    }, [min, max, processedMarks]);\n\n    const stepValue = useMemo(() => {\n        return step === null && isNil(processedMarks)\n            ? undefined\n            : calcStep(min, max, step);\n    }, [min, max, processedMarks, step]);\n\n    // Sanitize marks for rendering\n    const renderedMarks = useMemo(() => {\n        if (processedMarks === null) {\n            return null;\n        }\n        return sanitizeMarks({\n            min,\n            max,\n            marks: processedMarks,\n            step,\n            sliderWidth,\n        });\n    }, [min, max, processedMarks, step, sliderWidth]);\n\n    // Calculate dynamic input width based on min/max values\n    const inputWidth = useMemo(() => {\n        const maxIntegerChars = Math.max(\n            String(Math.floor(minMaxValues.max_mark)).length,\n            String(Math.floor(minMaxValues.min_mark)).length\n        );\n\n        const maxDecimalChars = Math.min(\n            (String(stepValue).split('.')[1]?.length ?? -1) + 1,\n            3\n        );\n\n        const totalChars = maxIntegerChars + maxDecimalChars;\n\n        return `calc(${totalChars}ch + calc(var(--Dash-Spacing) * 2))`;\n    }, [minMaxValues.min_mark, minMaxValues.max_mark, stepValue]);\n\n    const valueIsValid = (val: number): boolean => {\n        // Check if value is within min/max bounds\n        if (val < minMaxValues.min_mark || val > minMaxValues.max_mark) {\n            return false;\n        }\n\n        // If step is defined, check if value aligns with step\n        if (stepValue !== undefined) {\n            const min = minMaxValues.min_mark;\n            const offset = val - min;\n            const remainder = Math.abs(offset % stepValue);\n            const epsilon = 0.0001; // tolerance for floating point comparison\n            if (remainder > epsilon && remainder < stepValue - epsilon) {\n                return false;\n            }\n        }\n\n        // If step is null and marks exist, value must match a mark\n        if (\n            step === null &&\n            processedMarks &&\n            typeof processedMarks === 'object'\n        ) {\n            const markValues = Object.keys(processedMarks).map(Number);\n            const epsilon = 0.0001;\n            return markValues.some(mark => Math.abs(val - mark) < epsilon);\n        }\n\n        return true;\n    };\n\n    const constrainToValidValue = (val: number): number => {\n        // First constrain to min/max bounds\n        let constrained = Math.max(\n            minMaxValues.min_mark,\n            Math.min(minMaxValues.max_mark, val)\n        );\n\n        // If step is null and marks exist, snap to nearest mark\n        if (\n            step === null &&\n            processedMarks &&\n            typeof processedMarks === 'object'\n        ) {\n            return snapToNearestMark(constrained, processedMarks);\n        }\n\n        // If step is defined, round to nearest step\n        if (stepValue !== undefined) {\n            const min = minMaxValues.min_mark;\n            const steps = Math.round((constrained - min) / stepValue);\n            constrained = min + steps * stepValue;\n\n            // Round to avoid floating point precision issues\n            // Determine decimal places from step value\n            const stepStr = stepValue.toString();\n            const decimalPlaces = stepStr.includes('.')\n                ? stepStr.split('.')[1].length\n                : 0;\n            constrained = Number(constrained.toFixed(decimalPlaces));\n\n            // Ensure we stay within bounds after rounding\n            constrained = Math.max(\n                minMaxValues.min_mark,\n                Math.min(minMaxValues.max_mark, constrained)\n            );\n        }\n\n        return constrained;\n    };\n\n    const handleValueChange = (newValue: number[]) => {\n        let adjustedValue = newValue;\n\n        // Snap to nearest marks if step is null and marks exist\n        if (\n            step === null &&\n            processedMarks &&\n            typeof processedMarks === 'object'\n        ) {\n            const marks = processedMarks;\n            adjustedValue = newValue.map(val => snapToNearestMark(val, marks));\n        }\n\n        setValue(adjustedValue);\n        if (updatemode === 'drag') {\n            setProps({value: adjustedValue, drag_value: adjustedValue});\n        } else {\n            setProps({drag_value: adjustedValue});\n        }\n    };\n\n    const handleValueCommit = (newValue: number[]) => {\n        if (updatemode === 'mouseup') {\n            setProps({value: newValue});\n        }\n    };\n\n    const classNames = ['dash-slider-container', className].filter(Boolean);\n\n    // Determine if inputs should be rendered at all (CSS will handle responsive visibility)\n    const shouldShowInputs =\n        allow_direct_input !== false && // Not disabled by allow_direct_input\n        step !== null && // Not disabled by step=None\n        value.length <= 2 && // Only for single or range sliders\n        !vertical; // Only for horizontal sliders\n\n    return (\n        <LoadingElement>\n            {loadingProps => (\n                <div id={id} className={classNames.join(' ')} {...loadingProps}>\n                    {shouldShowInputs && value.length === 2 && (\n                        <input\n                            type=\"number\"\n                            className=\"dash-input-container dash-range-slider-input dash-range-slider-min-input\"\n                            style={{width: inputWidth}}\n                            value={isNaN(value[0]) ? '' : value[0]}\n                            onChange={e => {\n                                const inputValue = e.target.value;\n\n                                // Parse the input value\n                                const newMin = parseFloat(inputValue);\n                                const newValue = [newMin, value[1]];\n                                setValue(newValue);\n                                // Only update props if value is valid\n                                if (valueIsValid(newMin)) {\n                                    if (updatemode === 'drag') {\n                                        setProps({\n                                            value: newValue,\n                                            drag_value: newValue,\n                                        });\n                                    } else {\n                                        setProps({\n                                            drag_value: newValue,\n                                        });\n                                    }\n                                }\n                            }}\n                            onBlur={e => {\n                                const inputValue = e.target.value;\n                                let newMin: number;\n\n                                // If empty, default to current value or min_mark\n                                if (inputValue === '') {\n                                    newMin = isNaN(value[0])\n                                        ? minMaxValues.min_mark\n                                        : value[0];\n                                } else {\n                                    newMin = parseFloat(inputValue);\n                                    newMin = isNaN(newMin)\n                                        ? minMaxValues.min_mark\n                                        : newMin;\n                                }\n\n                                // Constrain to not exceed the max value\n                                newMin = Math.min(\n                                    value[1] ?? minMaxValues.max_mark,\n                                    newMin\n                                );\n\n                                // Snap to valid value (respecting step and marks)\n                                const constrainedMin =\n                                    constrainToValidValue(newMin);\n                                const newValue = [constrainedMin, value[1]];\n                                setValue(newValue);\n                                if (updatemode === 'mouseup') {\n                                    setProps({value: newValue});\n                                }\n                            }}\n                            pattern=\"^\\\\d*\\\\.?\\\\d*$\"\n                            min={minMaxValues.min_mark}\n                            max={isNaN(value[1]) ? max : value[1]}\n                            step={step || undefined}\n                            disabled={disabled}\n                        />\n                    )}\n                    {shouldShowInputs && (\n                        <input\n                            ref={inputRef}\n                            type=\"number\"\n                            className=\"dash-input-container dash-range-slider-input  dash-range-slider-max-input\"\n                            style={{width: inputWidth}}\n                            value={\n                                isNaN(value[value.length - 1])\n                                    ? ''\n                                    : value[value.length - 1]\n                            }\n                            onChange={e => {\n                                const inputValue = e.target.value;\n\n                                // Parse the input value\n                                const newMax = parseFloat(inputValue);\n                                const newValue = [...value];\n                                newValue[newValue.length - 1] = newMax;\n                                setValue(newValue);\n                                // Only update props if value is valid\n                                if (valueIsValid(newMax)) {\n                                    if (updatemode === 'drag') {\n                                        setProps({\n                                            value: newValue,\n                                            drag_value: newValue,\n                                        });\n                                    } else {\n                                        setProps({\n                                            drag_value: newValue,\n                                        });\n                                    }\n                                }\n                            }}\n                            onBlur={e => {\n                                const inputValue = e.target.value;\n                                let newMax: number;\n\n                                // If empty, default to current value or max_mark\n                                if (inputValue === '') {\n                                    newMax = isNaN(value[value.length - 1])\n                                        ? minMaxValues.max_mark\n                                        : value[value.length - 1];\n                                } else {\n                                    newMax = parseFloat(inputValue);\n                                    newMax = isNaN(newMax)\n                                        ? minMaxValues.max_mark\n                                        : newMax;\n                                }\n                                // Constrain to not be less than the min value\n                                newMax = Math.max(\n                                    value[0] ?? minMaxValues.min_mark,\n                                    newMax\n                                );\n\n                                // Snap to valid value (respecting step and marks)\n                                const constrainedMax =\n                                    constrainToValidValue(newMax);\n                                const newValue = [...value];\n                                newValue[newValue.length - 1] = constrainedMax;\n                                setValue(newValue);\n                                if (updatemode === 'mouseup') {\n                                    setProps({value: newValue});\n                                }\n                            }}\n                            pattern=\"^\\\\d*\\\\.?\\\\d*$\"\n                            min={\n                                value.length === 1\n                                    ? minMaxValues.min_mark\n                                    : value[0]\n                            }\n                            max={\n                                isNaN(minMaxValues.max_mark)\n                                    ? max\n                                    : minMaxValues.max_mark\n                            }\n                            step={step || undefined}\n                            disabled={disabled}\n                        />\n                    )}\n                    <div\n                        className=\"dash-slider-wrapper\"\n                        onClickCapture={e => e.preventDefault()} // prevent interactions from \"clicking\" the parent, particularly when slider is inside a label tag\n                    >\n                        <RadixSlider.Root\n                            ref={sliderRef}\n                            className={`dash-slider-root ${\n                                renderedMarks ? 'has-marks' : ''\n                            }`.trim()}\n                            style={{\n                                ...(vertical && {\n                                    height: `${verticalHeight}px`,\n                                }),\n                            }}\n                            value={value}\n                            onValueChange={handleValueChange}\n                            onValueCommit={handleValueCommit}\n                            min={minMaxValues.min_mark}\n                            max={minMaxValues.max_mark}\n                            step={stepValue}\n                            disabled={disabled}\n                            orientation={vertical ? 'vertical' : 'horizontal'}\n                            inverted={reverse}\n                            data-included={included !== false}\n                            minStepsBetweenThumbs={\n                                typeof pushable === 'number'\n                                    ? pushable\n                                    : undefined\n                            }\n                        >\n                            <RadixSlider.Track className=\"dash-slider-track\">\n                                {included !== false && (\n                                    <RadixSlider.Range className=\"dash-slider-range\" />\n                                )}\n                            </RadixSlider.Track>\n                            {renderedMarks &&\n                                renderSliderMarks(\n                                    renderedMarks,\n                                    !!vertical,\n                                    minMaxValues,\n                                    value,\n                                    !!dots,\n                                    !!reverse\n                                )}\n                            {dots &&\n                                stepValue &&\n                                renderSliderDots(\n                                    stepValue,\n                                    minMaxValues,\n                                    value,\n                                    !!vertical,\n                                    !!reverse\n                                )}\n                            {/* Render thumbs with tooltips for each value */}\n                            {value.map((val, index) => {\n                                const thumbClassName = `dash-slider-thumb dash-slider-thumb-${\n                                    index + 1\n                                }`;\n\n                                return (\n                                    <RadixSlider.Thumb\n                                        key={'thumb' + index}\n                                        className={thumbClassName}\n                                    >\n                                        {tooltip && (\n                                            <Tooltip\n                                                id={id}\n                                                index={index}\n                                                value={val}\n                                                tooltip={tooltip}\n                                            />\n                                        )}\n                                    </RadixSlider.Thumb>\n                                );\n                            })}\n                        </RadixSlider.Root>\n                    </div>\n                </div>\n            )}\n        </LoadingElement>\n    );\n}\n"],"names":["clamp","value","_ref","_ref2","min","max","Math","DirectionContext","React","Map","PAGE_KEYS","ARROW_KEYS","BACK_KEYS","SLIDER_NAME","_createCollection","name","PROVIDER_NAME","_createContextScope2","_slicedToArray","createContextScope","createCollectionContext","createCollectionScope","_createCollectionCont2","collectionRef","current","itemMap","CollectionProviderImpl","useCollectionContext","CollectionProvider","props","scope","children","ref","jsx","displayName","COLLECTION_SLOT_NAME","CollectionSlotImpl","createSlot","CollectionSlot","forwardedRef","context","composedRefs","useComposedRefs","ITEM_SLOT_NAME","ITEM_DATA_ATTR","CollectionItemSlotImpl","CollectionItemSlot","itemData","_objectWithoutProperties","_excluded","set","_objectSpread","delete","Provider","Slot","ItemSlot","collectionNode","orderedNodes","Array","from","querySelectorAll","concat","values","sort","a","b","indexOf","createCollection","_createCollection2","Collection","useCollection","createSliderContext","_createSliderContext2","SliderProvider","useSliderContext","Slider","_props$min","_props$max","_props$step","step","_props$orientation","orientation","_props$disabled","disabled","_props$minStepsBetwee","minStepsBetweenThumbs","_props$defaultValue","defaultValue","_props$onValueChange","onValueChange","_props$onValueCommit","onValueCommit","_props$inverted","inverted","form","sliderProps","thumbRefs","Set","valueIndexToChangeRef","SliderOrientation","SliderHorizontal","SliderVertical","_useControllableState2","useControllableState","prop","defaultProp","onChange","value2","_thumbs$valueIndexToC","focus","_useControllableState3","setValues","valuesBeforeSlideStartRef","updateValues","atIndex","commit","arguments","length","undefined","decimalCount","String","split","getDecimalCount","snapToStep","rounder","pow","round","roundValue","nextValue","prevValues","nextValues","getNextSortedValues","minStepsBetweenValues","stepsBetweenValues","slice","map","index","getStepsBetweenValues","hasMinStepsBetweenValues","hasChanged","__scopeSlider","thumbs","onPointerDown","composeEventHandlers","onSlideStart","closestIndex","distances","abs","closestDistance","getClosestValueIndex","onSlideMove","onSlideEnd","prevValue","onHomeKeyDown","onEndKeyDown","onStepKeyDown","event","stepDirection","direction","multiplier","includes","key","shiftKey","_createSliderContext4","startEdge","endEdge","size","SliderOrientationProvider","useSliderOrientationContext","localDir","globalDir","dir","_excluded2","_React$useState2","slider","setSlider","node","rectRef","isDirectionLTR","isSlidingFromLeft","getValueFromPointer","pointerPosition","rect","getBoundingClientRect","linearScale","width","left","SliderImpl","style","clientX","isBackKey","_excluded3","sliderRef","isSlidingFromBottom","height","top","clientY","_excluded4","Primitive","span","onKeyDown","preventDefault","target","setPointerCapture","pointerId","has","onPointerMove","hasPointerCapture","onPointerUp","releasePointerCapture","TRACK_NAME","SliderTrack","trackProps","_excluded5","RANGE_NAME","SliderRange","rangeProps","_excluded6","valuesCount","percentages","convertValueToPercentage","offsetStart","offsetEnd","THUMB_NAME","SliderThumb","getItems","_React$useState4","thumb","setThumb","findIndex","item","SliderThumbImpl","halfWidth","offset","thumbProps","_excluded7","_React$useState6","isFormControl","closest","useSize","percent","label","totalValues","getLabel","orientationSize","thumbInBoundsOffset","add","jsxs","transform","position","role","tabIndex","display","onFocus","SliderBubbleInput","_ref3","_excluded8","previous","usePrevious","input","inputProto","window","HTMLInputElement","prototype","setValue","Object","getOwnPropertyDescriptor","Event","bubbles","call","dispatchEvent","output","ratio","Root","Track","Range","Thumb","_curry2","test","obj","result","formatDecimalParts","x","p","i","toExponential","coefficient","prefixExponent","re","formatSpecifier","specifier","match","exec","Error","FormatSpecifier","fill","align","sign","symbol","zero","comma","precision","trim","type","this","d","exponent","join","toString","toFixed","toLocaleString","replace","toPrecision","formatRounded","floor","n","toUpperCase","formatPrefix","prefixes","locale","grouping","thousands","group","identity","Number","t","j","g","push","substring","reverse","currencyPrefix","currency","currencySuffix","decimal","numerals","formatNumerals","minus","nan","newFormat","formatTypes","prefix","toLowerCase","suffix","formatType","maybeSuffix","format","c","valuePrefix","valueSuffix","valueNegative","isNaN","s","out","i1","i0","formatTrim","charCodeAt","Infinity","padding","f","e","NaN","k","alignValue","v","alignIntValue","parseInt","num","alignDecimalValue","parseFloat","applyD3Format","mark","ten_factor","log10","max_min_mean","si_formatter","calcStep","isNil","diff","EPSILON","N","setUndefined","marks","definedMarks","min_mark","max_mark","marksObject","keys","autoGenerateMarks","sliderWidth","_estimateBestSteps","estimateBestSteps","minValue","maxValue","stepValue","niceMultiplier","formattedMin","formattedMax","minPixelsPerMark","effectiveWidth","targetMarkCount","rawMultiplier","magnitude","normalized","bestInterval","stepsInInterval","actualInterval","_estimateBestSteps2","start","interval","chosenStep","cursor","prevCursor","pop","forEach","sanitizeMarks","_setUndefined","truncated_marks","isEmpty","truncateMarks","pickBy","snapToNearestMark","markValues","reduce","getRadixThumbPosition","minMaxValues","thumbWidth","percentage","renderSliderMarks","renderedMarks","vertical","selectedValues","dots","entries","pos","displayPos","thumbPosition","bottom","isOutsideSelection","outsideClassName","className","renderSliderDots","dotCount","_","dotValue","displayValue","dotStyle","_ref4","_curry3","regex","replacement","str","_arity","fn","apply","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","_pipe","_curry1","_isArray","_isString","hasOwnProperty","symIterator","Symbol","iterator","_createReduce","arrayReduce","methodReduce","iterableReduce","xf","acc","list","next","TypeError","_xArrayReduce","idx","len","bind","thisObj","_xIterableReduce","iter","done","_xMethodReduce","methodName","XWrap","_checkForMethod","methodname","fromIndex","toIndex","_curryN","received","combined","argsIdx","combinedIdx","hasPlaceholder","_isPlaceholder","invoker","arity","method","_isFunction","isInteger","_nth","charAt","_path","pathAr","val","_isInteger","Tooltip","_tooltip$placement","tooltip","id","classNames","always_visible","placement","right","formatTooltipContent","transformSliderTooltip","funcName","func","pipe","path","formatSliderTooltip","template","MAX_MARKS","RangeSlider","setProps","updatemode","verticalHeight","propValue","included","pushable","allowCross","count","_props$allow_direct_i","allow_direct_input","_useState2","useState","_useState4","setSliderWidth","useRef","inputRef","useEffect","drag_value","measureWidth","dimension","resizeObserver","ResizeObserver","observe","disconnect","JSON","stringify","processedMarks","marksCount","console","error","useMemo","inputWidth","_String$split$1$lengt","_String$split$","maxIntegerChars","maxDecimalChars","valueIsValid","remainder","epsilon","some","constrainToValidValue","constrained","stepStr","decimalPlaces","handleValueChange","newValue","adjustedValue","handleValueCommit","filter","Boolean","shouldShowInputs","LoadingElement","loadingProps","_extends","inputValue","newMin","onBlur","_value$","pattern","newMax","_value$2","constrainedMax","onClickCapture","RadixSlider","thumbClassName"],"ignoreList":[],"sourceRoot":""}